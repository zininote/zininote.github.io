---
layout: post
title: "이진 탐색(Binary Search)으로 요소 찾기"
updated: 2021-04-13
tags: [algorithm,list]
---

## 리스트 안 데이터 요소 찾기

어떤 `seq` 리스트가 있고, 이 리스트 안에서 x 라는 요소가 어느 인덱스에 위치하는지를 찾는다고 하면, 리스트 앞에서부터 순차적으로 탐색하면 된다.

하지만 `seq` 가 오름차순으로 정렬 되어 있다면 굳이 앞에서부터 찾을 필요가 없다. 리스트 중간에 있는값과 x 를 비교해보고, 중간값 < x 라면, x 는 중간값 보다 크므로 큰 값들만으로 이뤄진 범위의 다시 중간값과 비교하고, 이런식으로 진행하면 훨씬 빠른 탐색이 가능하다. 보통 사전에서 단어를 찾을 때 사용하는 방식이다.

이런 데이터 요소 찾기 방법을 이진 탐색이라 한다. 자세한 건 [나무위키](https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89)를 참고해보자.

## 이진 탐색 로직

x 값을 찾기 위해 아래와 같은 과정으로 이진 탐색을 수행한다.

```txt
하한과 상한을 나타내는 lo, hi 변수를 상정, lo 는 0 번 인덱스, hi 는 len(seq) 인덱스를 가리킴 (~이상, ~미만 이라는 Python 의 범위 특성과 유사)
lo < hi 이라면 반복
    mid 변수가 중간 인덱스를 가리도록 함 (mid = (lo+hi)//2)
    만일 seq[mid] < x 라면, x 는 중간값이 있는 인덱스보다 훨씬 큰 인덱스에 위치하고 있다는 의미이므로, 하한 lo 를 mid 다음 인덱스까지 끌어올림 (lo = mid+1)
    만일 x < seq[mid] 라면, x 는 중간값이 있는 인덱스보다 훨씬 작은 인덱스에 위치하고 있다는 의미이므로, 상한 hi 를 mid 인덱스까지 끌어내림 (hi = mid)
    만일 x == seq[mid] 라면, 중간값이 있는 인덱스에 찾는 x 가 위치해있으므로 mid 리턴
반복문 모두 마쳤다면 x 값이 없었다는 의미이므로 None 리턴
```
{:.pseudo}

하한과 상한을 줄여가면서, 중간값과 찾는값을 계속 비교해가는 방식이다. 그리고 이런 **이진 탐색이 가능하려면 반드시 오름차순으로 정렬**이 되어있어야 한다.

## 예시

`seq` 라는 리스트가 아래와 같이 있다고 보자. (아래 리스트 또한 오름차순으로 정렬되어있다.) 이제 `seq` 에서 숫자 41 이 어느 위치(인덱스)에 있는지 찾고자 한다.

![그림00](/img/algorithm/algorithm-1030-01-01-00.svg)

제일 먼저 `seq` 의 하한과 상한 인덱스에 각각 lo, hi 표시를 한다. 그리고 중간값이 있는 인덱스를 mid 표시한다.

![그림01](/img/algorithm/algorithm-1030-01-01-01.svg)

mid 가 가리키는 31 은 찾고자 하는 41 보다 작다. 그러므로 31 을 포함하여 왼쪽에 있는 요소들은 버리고, 31 의 다음 인덱스에 lo 표시를 한다.

![그림02](/img/algorithm/algorithm-1030-01-01-02.svg)

다시 중간값에 해당하는 요소에 mid 표시를 한다.

![그림03](/img/algorithm/algorithm-1030-01-01-03.svg)

mid 가 가리키는 53 은 찾고자 하는 41 보다 크다. 그러므로 53 을 포함하여 오른쪽에 있는 요소들은 버리고, 53 이 있던 인덱스에 hi 표시를 한다.

![그림04](/img/algorithm/algorithm-1030-01-01-04.svg)

계속해서 아래와 같이 진행을 한다.

![그림05](/img/algorithm/algorithm-1030-01-01-05.svg)

![그림06](/img/algorithm/algorithm-1030-01-01-06.svg)

![그림07](/img/algorithm/algorithm-1030-01-01-07.svg)

드디어 mid 가 가리키는 값이 41 이므로, 41 값이 위치한 인덱스인 12 를 리턴하면 된다.

만일 `seq[12]` 가 41 이 아니었다면 어떻게 될까? 41 보다 큰 값이든 작은 값이든 임의의 수를 넣고 계속 로직을 진행시키다보면 lo < hi 라는 반복조건이 어느순간 깨지게 된다. 이 때는 찾는 값이 리스트 안에 없었다는 의미가 되므로 None 을 리턴하면 된다.

## Python 코드로 구현

```py
# 이진 탐색 코드
def bisearch(seq, x):
    lo, hi = 0, len(seq)

    while lo < hi:
        mid = (lo+hi)//2
        if seq[mid] < x: lo = mid+1
        elif x < seq[mid]: hi = mid
        else: return mid
    
    return None

# 사용 예시
seq = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
print(bisearch(seq, 41))    # 12
print(seq.index(41))        # 12

seq = [29, 31, 37, 41, 41, 41, 41, 41, 41, 41, 43, 47, 53]
print(bisearch(seq, 41))    # 6
print(seq.index(41))        # 3
```
{:.python}

위쪽 리스트는 이진 탐색이든 일반 탐색이든 똑같이 12 인덱스를 결과값으로 보이고 있다.

하지만 아래는 결과가 다른데, 중복값이 포함되어 있기 때문에다. 이진 탐색이라면 먼저 mid 에 걸리는 인덱스가 나오게 되고, 일반 탐색이라면 가장 왼쪽에 위치한 인덱스가 나오게 된다. 이런 경우를 피하고 싶다면 Python 자체적으로 제공하는 함수를 사용해보자.

## Python 제공 함수

Python 은 보다 범용적으로 사용할 수 있도록 bisect 모듈에서 bisect_left 와 bisect_right 함수를 제공한다.

```py
seq = [29, 31, 37, 41, 41, 41, 41, 41, 41, 41, 43, 47, 53]
print(bisect_left(seq, 33))     # 2
print(bisect_right(seq, 33))    # 2

print(bisect_left(seq, 41))     # 3
print(bisect_right(seq, 41))    # 10
```
{:.python}

간단히 설명하자면, 오름차순으로 정렬된 리스트 안에서, 어느 인덱스에 주어진 숫자를 넣어야 리스트가 계속 오름차순을 유지하느냐를 반환하는 함수다. 따라서 None 을 반환하는 일은 없다.

중복값이 없다면 bisect_left 든 bisect_right 든 동일한 결과를 보이지만, 중복값이 존재한다면 bisect_left 는 중복값의 가장 왼쪽 인덱스를, bisect_right 는 중복값의 가장 오른쪽 인덱스를 결과로 내보인다.

보다 자세한 내용을 알고 싶다면 [Python 공식문서](https://docs.python.org/ko/3/library/bisect.html)를 참고하자.
