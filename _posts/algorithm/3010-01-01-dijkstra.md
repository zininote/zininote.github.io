---
layout: post
title: "다익스트라 알고리즘 - 시작 노드에서 다른 노드까지 최소거리 찾기"
updated: 2021-04-04
tags: [algorithm,graph]
---

## 다익스트라 알고리즘

어떤 그래프가 있을 때, 시작 노드로부터 다른 노드들까지의 최단거리를 찾아내는 알고리즘이다. [나무위키](https://namu.wiki/w/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)나 포털에서 "다익스트라"로 찾아보면 그 개념과 원리에 대해 설명해 놓은 글들을 쉽게 찾아볼 수 있다.

이 포스팅에서는 다익스트라의 개념과 알고리즘 원리보다는, 실제로 최단경로를 찾아가는 과정과, Python 으로 구현한 코드를 소개하고자 한다.

## 최단 거리 찾는 과정

위에서 언급한 나무위키 사이트 안에 있는 아래와 같은 그래프를 탐색한다고 가정한다. 시작노드는 `A` 이다.

![그림00](/img/algorithm/algorithm-0025.svg)

그리고 두 변수를 사용하여 탐색을 진행한다. `dist` 는 결과물(각 노드별로 `A` 로부터 최단거리, 그도안 거쳐온 경로) 을 저장할 변수이고, `q` 는 다음으로 탐색할 노드를 정하기 위해 사용할 우선순위 큐이다. 우선순위 큐는 바이너리 힙을 이용한 자료구조로, 자료들을 넣었을 때 넣은 순서와 관계없이 항상 최소값을 Pop(추출) 한다. `q` 에 저장된 값들 중 가장 거리가 작은 값들부터 탐색할 것이다. 우선순위 큐에 사용되는 바이너리 힙에 대해서는 [별도 포스팅](/post/binary-heap-structure)을 참고해보기 바란다.

먼저 본격적인 알고리즘에 들어가기 직전에 초기화를 한다. 모든 노드가 탐색 전이므로, `dist` 의 각 노드까지의 거리는 무한대 값을 넣고 경로는 비워둔다. 그리고 `q` 에는 시작노드의 정보를 담는다. (거리, 노드, 경로) 의 튜플 패턴을 사용할 것이다. 시작노드이기에 `(0, A, [])` 값을 넣었는데, 시작노드이기 때문에 시작노드로부터의 거리는 0 이고, 다른 노드를 거쳐오기 않기에 경로에는 빈 리스트가 사용되었다.

![그림01](/img/algorithm/algorithm-0026.svg)

이제 반복구조를 통해서 최단 거리를 찾기 시작한다. 기본적인 로직은 아래와 같다.

```txt
q 에서 최단거리 노드 정보를 Pop
Pop 한 노드정보의 거리 < dist 안의 노드정보의 거리 인 경우...
    dist 안의 거리를 Pop 한 노드정보 거리로 갱신 (기존에 알던 거리보다 최단거리가 발견되었으므로)
    해당 노드의 인근 노드 정보를 q 에 삽입
Pop 한 노드정보의 거리 >= dist 안의 노드정보의 거리 인 경우...
    특별한 작업 없음 (새로운 최단경로가 아닌 정보는 버리며, 인근 노드로의 확대도 불필요)
q 가 비어있을 때까지 계속 반복
```
{:.pesudo}

위 로직대로 다시 진행하면 먼저 `q` 를 Pop 하게 된다. `(0, A, [])` 가 나오는데, Pop 결과물의 거리와 `dist` 데이터의 거리를 비교한다. Pop 결과물의 거리로 `dist` 갱신을 한다. 새로운 최단경로가 나타났기 때문이다. 그리고 다음으로 방문 가능한 노드 정보를 `q` 에 삽입한다. 여기까지 진행하면 아래와 같다.

![그림02](/img/algorithm/algorithm-0027.svg)

다음 반복 턴에서는 `(10, B, [A])` 를 Pop 하게 된다. 우선순위 큐 특성으로 거리가 제일 작은 노드정보를 Pop 한다. 거리가 현재 `dist` 의 거리보다 작으므로, Pop 결과물로 갱신하고, 다음으로 방문 가능한 노드 정보를 `q` 에 삽입한다. 아래와 같은 상태가 된다.

![그림03](/img/algorithm/algorithm-0028.svg)

다음 반복 턴에서는 `(15, D, [A])` 가 Pop 된다. 이 역시 갱신과 다음 방문 가능한 노드를 `q` 에 삽입하게 된다.

![그림04](/img/algorithm/algorithm-0029.svg)

다음 턴의 노드 정보는 `( 20, C, [A,D] )` 이다. 아래와 같이 된다.

![그림05](/img/algorithm/algorithm-0030.svg)

다음 턴의 노드 정보는 `( 25, F, [A,D,C] )` 이다. 아래와 같이 된다

![그림06](/img/algorithm/algorithm-0031.svg)

다음 턴의 노드 정보는 `( 30, C, [A] )` 이다. 하지만 `C` 노드는 이미 최단거리가 20 으로 계산되어 있다. 새로운 최단거리가 아니므로 이 노드 정보는 특별한 작업없이 버린다.

다음 턴의 노드 정보는 `( 30, E, [A,B] )` 이다. 아래와 같이 된다.

![그림07](/img/algorithm/algorithm-0032.svg)

아직 `q` 에 노드 정보가 남아있으므로 반복은 계속되는데, 보면 알겠지만 그 어느것도 최단거리 갱신이 불가능한 노드 정보들이다. 특별한 작업없이 반복을 통해 버려지게 된다. 사실상 위 그림의 `dist` 정보가 `A` 로부터 각 노드에 도달할 수 있는 최단거리 및 그 경로가 된다.

## Python 코드로 구현

위에서 설명한 내용들을 코드로 아래처럼 나타냈다. 먼저 그래프인데 `{노드: {방문가능한노드: 거리, ...}, ...}` 형태로 표현하였다.

```py
g = {
    'A': {'B': 10, 'C': 30, 'D': 15},
    'B': {'E': 20},
    'C': {'F': 5},
    'D': {'C': 5, 'F': 20},
    'E': {'F': 20},
    'F': {'D': 20},
}
```
{:.python}

그리고 아래와 같이 다익스트라 알고리즘을 코드로 나타냈다.

```py
from queue import PriorityQueue
import sys

def dijkstra(n, g):
    #1 dist, q 초기화
    dist, q = {}, PriorityQueue()
    for x in g.keys(): dist[x] = {'d': sys.maxsize, 'path': None}
    q.put((0, n, []))

    #2 다익스트라 알고리즘 핵심 코드
    while not q.empty():
        d, n, path = q.get()
        if d < dist[n]['d']:
            dist[n] = {'d': d, 'path': path}
            for nn, nd in g[n].items(): q.put((d+nd, nn, path+[n]))

    return dist
```
{:.python}

`#1` 에서 초기화한 `dist`, `q` 는 각각 시작노드로부터의 정보, 우선순위 큐를 나타낸다. 특히 `dist` 는 `{노드: {'d': 시작노드로부터의 최단거리, 'path': 해당노드까지 오기위해 앞서 거치는 노드}}` 정보를 담는다. 그리고 본격적인 반복문에 들어가기 전에 `dist` 를 초기화하고, 우선순위 큐에 담는다. 참고로 초기화에는 무한대 값 대신 sys 모듈의 정수 한계치를 사용했다.

`#2` 는 우선순위 큐에서 최단거리 노드를 찾아서, 거리가 최단인 큐에서 최단거리 노드를 추출해서, 거리가 더 최단이라면 해당 노드의 거리와 경로를 갱신한다. 그리고, 다음으로 방문가능한 인접 노드들을 순회하면서, 우선순위 큐에 거리 등 정보를 담아 삽입한다.

아래는 그래프 `g` 를 가지고 dijkstra 함수를 사용한 결과다. 보기 좋게 나타나도록 pprint 모듈의 pprint 함수를 사용했다.

```py
from pprint import pprint
pprint(dijkstra('A', g))

# {'A': {'d': 0, 'path': []},
#  'B': {'d': 10, 'path': ['A']},
#  'C': {'d': 20, 'path': ['A', 'D']},
#  'D': {'d': 15, 'path': ['A']},
#  'E': {'d': 30, 'path': ['A', 'B']},
#  'F': {'d': 25, 'path': ['A', 'D', 'C']}}
```
{:.python}
